/*********************************************************************************************
(c) 2005-2015 Copyright, Real-Time Innovations, Inc.  All rights reserved. 
RTI grants Licensee a license to use, modify, compile, and create derivative works 
of the Software.  Licensee has the right to distribute object form only for use with RTI 
products.  The Software is provided “as is”, with no warranty of any type, including 
any warranty for fitness for any purpose. RTI is under no obligation to maintain or 
support the Software.  RTI shall not be liable for any incidental or consequential 
damages arising out of the use or inability to use the software.
**********************************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;


/* For the Sparx Automation APIs see:
 * http://bellekens.com/2011/01/29/tutorial-create-your-first-c-enterprise-architect-addin-in-10-minutes/
 * https://alexatnet.com/articles/creating-addin-for-sparx-enterprise-architect 
 * http://blog.sparxsystems.eu/2015/05/the-enterprise-architect-object-model-ea-api/ 
 * http://bellekens.com/writing-ea-add-ins/ 
 */

using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Drawing;
using EA;

namespace IDL4_EA_Extension
{
    public class IDLGenAction : UserActionInterface
    {
        private EA.Repository _currentRepository = null;
        private TextOutputInterface _currentOutput = null;
        private HashSet<string> _uncheckedElements = null;

        public void Initialize(EA.Repository repository, TextOutputInterface output,
            HashSet<string> uncheckedElements)
        {
            _currentRepository = repository;
            _currentOutput = output;
            _uncheckedElements = uncheckedElements;
        }

        public void OnCodegenAction()
        {
            Main.GenIDL(_currentRepository, _currentOutput, _uncheckedElements);
        }

        public void OnSaveAction(string filePath)
        {
            String[] preambleLines = {
               "/*",
               " *  IDL file generated by RTI Connext DDS Enterprise Architect IDL 4 Add-in version 1.0",
               " *      Enterprise Architect File:  " + _currentRepository.ConnectionString,
               " *      Date: " + DateTime.Now.ToString(),
               " */",
               " "
            };

            _currentOutput.SaveToFile(filePath, preambleLines);
        }

        public void OnSelectAction(TreeNode treeNode)
        {
            OnDebugAction("Selected Node: " + treeNode.FullPath);
            Main.GenIDL_Preview(_currentRepository, _currentOutput, _uncheckedElements, treeNode.FullPath);
        }

        public void OnCheckAction(TreeNode treeNode)
        {
            // Remember whether it is uncheked or not
            if (treeNode.Checked)
            {
                _uncheckedElements.Remove(treeNode.FullPath);
            }
            else
            {
                _uncheckedElements.Add(treeNode.FullPath);
            }
        }

        public void OnDebugAction(string text)
        {
            _currentOutput.OutputTextLine(text);
        }
    }

    [ComVisible(true)]
    public class Main 
    {

        private const String MENU_ROOT_RTI_CONNEXT  = "- IDL4  (RTI Connext DDS)";
        private const String MENU_ITEM_GENERATE_XML = "Generate IDL ...";

        // Called Before EA starts to check Add-In Exists
        public string EA_Connect(Repository repository)
        {
            // nothing special
            return "EaProjectStats.AddIn - connected";
        }
        // EA calls this operation when it exists. Can be used to do some cleanup work.
        public void EA_Disconnect()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }

        // Called when user Click Add-Ins Menu item.
        public object EA_GetMenuItems(Repository repository,
            string location, string menuName)
        {
            switch (menuName)
            {
                case "":
                    return MENU_ROOT_RTI_CONNEXT;
                case MENU_ROOT_RTI_CONNEXT:
                    return MENU_ITEM_GENERATE_XML;
            }
            return "";
        }

        // Sets the state of the menu depending if there is
        // an active project or not
        static bool EA_IsProjectOpen(Repository repository)
        {
            try
            {
                return null != repository.Models;
            }
            catch
            {
                return false;
            }
        }

        // Called once Menu has been opened to see what menu
        // items are active.
        public void EA_GetMenuState(Repository repository,
            string location, string menuName, string itemName,
            ref bool isEnabled, ref bool isChecked)
        {
            if (EA_IsProjectOpen(repository))
            {
                if (itemName == MENU_ROOT_RTI_CONNEXT)
                    isEnabled = true;
            }
            else
                // If no open project, disable all menu options
                isEnabled = false;
        }


        // Called when user makes a selection in the menu.
        // This is your main exit point to the rest of your Add-in
        public void EA_MenuClick(Repository repository,
            string location, string menuName, string itemName)
        {

            switch (itemName)
            {
                case MENU_ITEM_GENERATE_XML:
                    IDLGenAction idlGenAction = new IDLGenAction();
                    IDLClassSelector idlClassSelector = new IDLClassSelector(idlGenAction);
                    TextBoxOutputAdapter output = new TextBoxOutputAdapter(idlClassSelector.getTextBox());
                    HashSet<string> uncheckedElements = new HashSet<string>();
                    idlGenAction.Initialize(repository, output, uncheckedElements);

                   // GenerateIDL(repository, output);

                    PopulateClassSelector(idlClassSelector, repository);
                    idlClassSelector.Text = "IDL4 (RTI Connext DDS) - Select classes for IDL generation"; 
                    idlClassSelector.Show();
                    //idlGenAction.OnCodegenAction();
                    break;
            }
        }

        public static void PopulateClassSelector(IDLClassSelector classSelector, Repository repository)
        {
            TreeNodeCollection treeNodes = classSelector.getTreeView().Nodes;

            foreach (Package model in repository.Models)
            {
                TreeNode newNode = new TreeNode(model.Name);
                newNode.Checked = true;
                newNode.Expand();
                treeNodes.Add(newNode);

                foreach (Package package in model.Packages)
                {
                    PopulateClassSelector(newNode, package);
                }
            }
        }

        public static void PopulateClassSelector(TreeNode parentNode, Package package)
        {
            TreeNode packageNode = new TreeNode(package.Name);
            packageNode.Checked = true;
            packageNode.Expand();
            parentNode.Nodes.Add(packageNode);


            foreach (Element e in package.Elements)
            {
                if (IsClass(e))
                {
                    TreeNode classNode = new TreeNode(e.Name);
                    classNode.Checked = true;
                    packageNode.Nodes.Add(classNode);
                }
            } 

            foreach (Package p in package.Packages)
            {
                PopulateClassSelector(packageNode, p);
            }
        }

        /** Finds a child of an EA Model element capturing exceptions raised if the child is not
         * found.
         * 
         */
        private static Object EAUtil_FindChild(EA.Collection collection, String childName)
        {
            Object child = null;
            try {
                child = collection.GetByName(childName);
            }
            catch (Exception) {}

            return child;
        }

        internal static void GenIDL_Preview(Repository repository, TextOutputInterface output, 
            HashSet<string> uncheckedElem, String fullPath)
        {
            char[] delimiterChars = { '\\'};
            String[] elementNames = fullPath.Split(delimiterChars);

            Package package = (Package)EAUtil_FindChild(repository.Models, elementNames[0]);
            //Package model = (Package)repository.Models.GetByName(elementNames[0]);
            if (package == null)
            {
                output.OutputTextLine("// Could not find selected package: \"" + fullPath + "\" in the model");
                return;
            }

            Package parentPackage = package;
            Element  classElem = null;
            for (int i = 1; i < elementNames.Length; ++i, parentPackage = package)
            {
                String elemName = elementNames[i];

                package = (Package)EAUtil_FindChild(parentPackage.Packages, elemName);
                //package = (Package)parentPackage.Packages.GetByName(elemName);

                if ((package == null) && (i == elementNames.Length - 1))
                {
                    classElem = (Element)EAUtil_FindChild(parentPackage.Elements, elemName);
                }
            }

            output.Clear();
            if (package == null && classElem == null)
            {
                output.OutputTextLine("// Could not find selected element: \"" + fullPath + "\" in the model");
                return;
            }

            for (int i = 1; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("module " + IDL_NormalizeUserDefinedClassifierName(elementNames[i]) + " {  ");
            }
            output.OutputTextLine();
            if (package != null)
            {
                // display package
                // output.OutputTextLine("Displaying Package: " + package.Name);
                Dictionary<long, bool> moduleRelevance = new Dictionary<long, bool>();
                UpdateModuleRelevance(moduleRelevance, package, output);
                Main.GenIDL_ModuleFirstPass(repository, package, output, elementNames.Length - 1, null, null, moduleRelevance);
                Main.GenIDL_ModuleSecondPass(repository, package, output, elementNames.Length - 1, null, null, moduleRelevance, null);
            }
            else if (classElem != null)
            {
                // display class
                // output.OutputTextLine("Displaying Class: " + classElem.Name);
                if (IsElementEnum(classElem))
                {
                    Main.GenIDL_Enum(repository, classElem, output, elementNames.Length - 1, null, "");
                }
                else
                {
                    Main.GenIDL_Class(repository, classElem, output, elementNames.Length - 1, null, "");
                 }
            }
            for (int i = 1; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("};");
            }
        }

        /** Outputs UML "primitive" types that are not primitive in IDL
         */
        private static void GenIDL_PrebuiltUMLTypes(TextOutputInterface output)
        {
            String builtinTypes = 
                "struct dateTime { long date; long time; };";
            output.OutputTextLine(builtinTypes);
        }

        internal static void GenIDL(Repository repository, TextOutputInterface output, HashSet<String> uncheckedElem)
        {
            output.Clear();

            output.OutputTextLine("/* ******************************************************************* */");
            output.OutputTextLine("/* These are UML builtin primitive types that are not primitive in IDL */");
            GenIDL_PrebuiltUMLTypes(output);
            output.OutputTextLine("");

            output.OutputTextLine("/* ******************************************************************* */");
            output.OutputTextLine("/* These are Types defined in the model */");
            output.OutputTextLine("");

            // moduleRelevance holds the modules relevant for IDL generation
            Dictionary<long, bool> moduleRelevance = new Dictionary<long, bool>();

            // completedClasses holds the classes for which code has been completele generated
            // such that we can generate code that depends on these classes
            HashSet<long> completedClasses = new HashSet<long>();

            foreach (Package model in repository.Models)
            {
                if (uncheckedElem.Contains(model.Name) )
                {
                    // if unckecked skip this model
                    continue;
                }

                UpdateModuleRelevance(moduleRelevance, model, output);
            }

            foreach (Package model in repository.Models)
            {
                if (uncheckedElem.Contains(model.Name))
                {
                    // if unckecked skip this model
                    continue;
                }

                output.OutputTextLine("/* -----  Model: \"" + model.Name + "\"  ----- */");
                foreach (Package package in model.Packages)
                {
                    GenIDL_ModuleFirstPass(repository, package, output, 0, model.Name, uncheckedElem, moduleRelevance);
                }
            }

            bool generationComplete = false;
            int iterationCount = 0;
            int maxPasses = 3;

            while (!generationComplete && (iterationCount < maxPasses))
            {
                generationComplete = true;
                ++iterationCount;
                foreach (Package model in repository.Models)
                {
                    if (uncheckedElem.Contains(model.Name))
                    {
                        // if unckecked skip this model
                        continue;
                    }

                    foreach (Package package in model.Packages)
                    {
                        bool pkgGenerationComplete = GenIDL_ModuleSecondPass(repository, package, output, 0, model.Name, uncheckedElem, moduleRelevance, completedClasses);
                        generationComplete = generationComplete && pkgGenerationComplete;
                    }
                }
                if (generationComplete)
                {
                    break;
                }
            }

            if ( generationComplete == false )
            {
                output.OutputTextLine("/* WARNING: Some classes could not be generated due to dependencies */");
            }
        }

        private static void GenIDL_ClassTypedef(Element classElem, TextOutputInterface output, int depth)
        {
            output.OutputTextLine(depth, "struct " + IDL_NormalizeUserDefinedClassifierName(classElem.Name + ";"));
        }

        /** Generate IDL4 module corresponding to the UML package
         * 
         *  This function is the first-pass module generation. It generates the things that
         *  have no dependiencies on anything else and help resilve depenedencies for the types
         *  that depend on this module. These are:
         *  
         *  enums
         *  typedefs for all structures defined in the module.
         *  
         *  This function is recursive. It generates IDl for all the nested UML packages as well
         *  
         *
         */
        private static void GenIDL_ModuleFirstPass(Repository repository, Package package,
            TextOutputInterface output, int depth, String pathToElem,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules)
        {
            // if unckecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if (IsElementUnchecked(uncheckedElem, packageFullName))
            {
                return;
            }

            if ( !IsModuleRelevant(relevantModules, package, output) )
            {
                output.OutputTextLine(depth, "// Skipping empty module: " + package.Name);
                return;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);
            bool emptyModuleContent = true;
            output.OutputTextLine(depth, "module " + moduleName + " {");
 
            foreach (Element e in package.Elements)
            {
                if (IsElementEnum(e))
                {
                    GenIDL_Enum(repository, e, output, depth + 1, uncheckedElem, packageFullName);
                    emptyModuleContent = false;
                }
                else
                {
                    if (GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, null))
                    {
                        GenIDL_ClassTypedef(e, output, depth + 1);
                        emptyModuleContent = false;
                    }
                }
            }

            foreach (Package p in package.Packages)
            {
                GenIDL_ModuleFirstPass(repository, p, output, depth + 1, packageFullName, uncheckedElem, relevantModules);
                emptyModuleContent = false;
            }

            if (emptyModuleContent)
            {
                GenIDL_EmptyModuleContent(moduleName, output, depth + 1);
            }
            output.OutputTextLine(depth, "}; /* end: " + moduleName + " */");
            output.OutputTextLine();
        }

        /** Generate IDL4 module corresponding to the UML package
         * 
         *  This function is recursive. It generates IDl for all the nested UML packages and classes
         *  
         * Returns true if generation of all classes is complete. Otherwise false.
         * If generation is incompete (i.e. when it returns false) the function should be called
         * again an again (in successive passes) to complete the generation of classes that were ommitted 
         * on the previous pass.
         * 
         * Each pass generates the classes for with GenIDL_DependenciesAlreadyGenerated() which means the
         * classes that have any dependent classes already generated.
         * 
         * If no progress is made on successive calls it indicates a dependency cycle which must be broken
         * by making one of the dependencies a "@Shared" reference
         */
        private static bool GenIDL_ModuleSecondPass(Repository repository, Package package, 
            TextOutputInterface output, int depth, String pathToElem,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules,HashSet<long> completedClasses )
        {
            bool generationComplete = true;

            // if unckecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if (IsElementUnchecked(uncheckedElem, packageFullName)) 
            {   
                return true;
            }

            if (!IsModuleRelevant(relevantModules, package, output))
            {
                return true;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);
            bool emptyModuleContent = true;
            output.OutputTextLine(depth, "module " + moduleName + " {");
           
            foreach (Element e in package.Elements)
            {
                // Skip Enum as they are generated on the first pass
                if ( !IsElementEnum(e) )
                {
                    if (GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, completedClasses))
                    {
                        if ( GenIDL_DependenciesAlreadyGenerated(repository, e, output, completedClasses) )
                        {
                            GenIDL_Class(repository, e, output, depth + 1, uncheckedElem, packageFullName);
                            emptyModuleContent = false;
                            completedClasses.Add(e.ElementID);
                        }
                        else
                        {
                            generationComplete = false;
                        }
                    }
                }
            }
            
            foreach (Package p in package.Packages)
            {
                bool nestedGenerationComplete = GenIDL_ModuleSecondPass(repository, p, output, depth + 1, packageFullName, 
                    uncheckedElem, relevantModules, completedClasses);
                generationComplete = generationComplete && nestedGenerationComplete;
                emptyModuleContent = false;
            }

            if (emptyModuleContent)
            {
                GenIDL_EmptyModuleContent(moduleName, output, depth + 1);
            }
            output.OutputTextLine(depth, "}; /* end: " + moduleName + " */");
            output.OutputTextLine();

            return generationComplete;
        }


        /* Generate the IDL for an enum literal.
         */
        private static void GenIDL_EnumLiterals(Repository repository, String enumName, Element enumElem, TextOutputInterface output, int depth)
        {
            short childCount = enumElem.Attributes.Count;
            for (short i = 0 ; i < childCount; ++i ) 
            {
                EA.Attribute child = enumElem.Attributes.GetAt(i);
                String typeName = IDL_NormalizeMemberTypeName(child.Type);
                if (i < childCount - 1)
                {
                    output.OutputText(depth, typeName + "  " + enumName + "_" + child.Name + ",");
                }
                else
                {
                    output.OutputText(depth, typeName + "  " + enumName + "_" + child.Name);
                }

                string[] relevantAnnotationsWithValue = new string[] {
                    "ID", "Value"
                };
                foreach (AttributeTag tag in child.TaggedValues)
                {
                    String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);
                    if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                    {
                        output.OutputText(" //@" + normalizedAnnotation + " " + tag.Value);
                    }
                }

                output.OutputTextLine();
            }
        }

        private static String GenIDL_GetFullPackageName(Repository repository, Element elem)
        {
            String packageName = "";
            int packageID = elem.PackageID;
            Package package = repository.GetPackageByID(packageID);
            int parentPackageID = package.ParentID;

            while (parentPackageID != 0)
            {
                packageName = IDL_NormalizeUserDefinedClassifierName(package.Name) + "::" + packageName;
                packageID = parentPackageID;
                package = repository.GetPackageByID(packageID);
                parentPackageID = package.ParentID;
            }

            return packageName;
        }

        /* Generate the IDL for an attribute.
         * The atribute can appear by itself, a sequence, or an array.
         * The determinaton of this is based on the settings of LowerBound and UpperBound
         *    
         *    UpperBound == 0                 ==>  Unbounded Sequence
         *    LowerBound == UpperBound == 1        ==>  Single member (no Array/Sequence)
         *    LowerBound == 0 && UpperBound == 1   ==>  Optional single member
         *    
         *    LowerBound  < UpperBound  (other values)    ==>  Bounded Sequence
         *    LowerBound == UpperBound  (other values)    == > Array
         *    
         * returns true if it outputs some attribute; otherwise returns false 
         */
        private static bool GenIDL_Attributes(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            //TODO: Empty classes are not legal IDL. So if class is empty add some dummy element
            if (classElem.Attributes.Count == 0)
            {
                return false;
            }


            foreach (EA.Attribute child in classElem.Attributes)
            {
                // This does not get the fully qualified type name. We need that to fully resolve
                // the type in the IDL...
                String typeName;
                
                /* This code was trying to get the fully-qualified name but it throws an exception
                 */
                if ( child.ClassifierID == 0 ) {
                    typeName = IDL_NormalizeMemberTypeName(child.Type);
                }
                else {
                    Element attributeType = repository.GetElementByID(child.ClassifierID);
                    Package attributePackage = repository.GetPackageByID(attributeType.PackageID);
                    typeName = GenIDL_GetFullPackageName(repository, attributeType) 
                        + IDL_NormalizeMemberTypeName(attributeType.Name);
                }

                // output.OutputText(depth, "/* child.ClassifierID = " + child.ClassifierID + " */");

                int lower  = Convert.ToInt32(child.LowerBound);
                int upper = Convert.ToInt32(child.UpperBound);

                if (upper == 0) // Unbounded sequence
                {
                    output.OutputText(depth, "sequence<" + typeName + "> " + child.Name + ";");
                }
                else if (lower == upper)
                {
                    if (upper == 1) // Single member
                    {
                        output.OutputText(depth, typeName + "  " + child.Name + ";" );
                    }
                    else // Array
                    {
                        output.OutputText(depth, typeName + " " + child.Name + "[" + child.UpperBound + "];");
                    }
                }
                else if (lower == 0 && upper == 1) // optional
                {
                    output.OutputText(depth, typeName + " " + child.Name + "; //@Optional");
                }
                else // bounded sequence
                {
                    output.OutputText(depth, "sequence<" + typeName + "," + child.UpperBound + "> "
                        + child.Name + " ;");
                }
                
                string[] relevantAnnotationsNoValue = new string[] {
                    "Key", "must_understand",
                    "autoid", "Optional",
                    "external", "nested",
                    "oneway", "ami"
                };
                string[] relevantAnnotationsWithValue = new string[] {
                    "ID", "Value"
                };
                foreach (AttributeTag tag in child.TaggedValues)
                {
                    String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);
                    if ( relevantAnnotationsNoValue.Contains(normalizedAnnotation) ) 
                    {
                        output.OutputText(" //@" + normalizedAnnotation);
                    }
                    else if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                    {
                        output.OutputText(" //@" + normalizedAnnotation + " " + tag.Value);
                    }
                }

                output.OutputTextLine();
            }

            return true;
        }

        private static String GenIDL_GetReferencedTypeToInclude(Repository repository, Element classElem, EA.Connector conn )
        {
            string[] relevantConnectorTypes = new string[] { "Aggregation", "Association" };
            if (!relevantConnectorTypes.Contains(conn.Type))
            {
                return null;
            }
            
            ConnectorEnd target = conn.SupplierEnd;
            ConnectorEnd source = conn.ClientEnd;

            if (classElem.ElementID == conn.ClientID)
            {
                // We are source of relationship
                if ( (source.Aggregation != 0)
                    && (            
                        conn.Direction.Equals("Source -> Destination") ||
                        conn.Direction.Equals("Bi-Directional"))
                    )
                {
                    return repository.GetElementByID(conn.SupplierID).Name;
                }
            }
            else
            {
                // We are target of relationship
                if ( (target.Aggregation != 0)
                    && (            
                        conn.Direction.Equals("Destination -> Source") ||
                        conn.Direction.Equals("Bi-Directional"))
                    )
                {
                    return repository.GetElementByID(conn.ClientID).Name;
                }

            }

            return null;
        }

        private static bool GenIDL_Relations(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            bool generatedRelationship = false;

            foreach (EA.Connector conn in classElem.Connectors)
            {
                String referencedType = GenIDL_GetReferencedTypeToInclude(repository, classElem, conn);
                // textForm.getTextBox().AppendText("    type: " + conn.Type  + Environment.NewLine);

                if (referencedType != null)
                {
                    String connName = conn.Name;
                    output.OutputTextLine(depth, referencedType + "  " + connName + ";");
                    generatedRelationship = true;
                }
            }

            return generatedRelationship;
        }

        private static String IDL_FullElementName(String elementPath, String elementName)
        {
            return elementPath + "\\" + elementName;
        }

        private static bool IsElementUnchecked(HashSet<String> uncheckedElem, String elementFullName) 
        {
            return (uncheckedElem != null) && (uncheckedElem.Contains(elementFullName));
        }

        private static bool IsElementUnchecked(HashSet<String> uncheckedElem, String elementPath, String elementName)
        {
            if (uncheckedElem == null)
            {
                return false;
            }
            return uncheckedElem.Contains(IDL_FullElementName(elementPath, elementName));
        }

        private static bool IsElementEnum(Element elem)
        {
            // TODO
            return elem.Stereotype.Equals("enumeration");
        }

        /**
         *  This function traverses the package, recursively visiting all its children, and updates
         *  the moduleRelevance dictionary storing whether each individual module is relevant or not
         *  
         * Relevance is currently defined as not being empty for the purposes of IDL generation. This
         * means having some class, some enumeration, or recursively containing a relevant sub-package
         */
        private static bool UpdateModuleRelevance(Dictionary<long, bool> moduleRelevance, Package package,
            TextOutputInterface output)
        {
            bool relevantModule = false;

            foreach (Package p in package.Packages)
            {
                relevantModule = UpdateModuleRelevance(moduleRelevance, p, output) || relevantModule;
            }

            if (relevantModule == false)
            {
                foreach (Element e in package.Elements)
                {
                    if (IsElementEnum(e) || IsClass(e))
                    {
                        relevantModule = true;
                        break;
                    }
                }
            }
            moduleRelevance.Add(package.PackageID, relevantModule);

            return relevantModule;
        }

        private static bool IsModuleRelevant(Dictionary<long, bool> moduleRelevance, Package package, TextOutputInterface output)
        {
            bool isRelevant = true;
            if (!moduleRelevance.TryGetValue(package.PackageID, out isRelevant))
            {
                output.OutputTextLine("IsModuleRelevant; Error did not find: " + package.Name);
                return true;
            }
            return isRelevant;
        }

        private static void GenIDL_Enum(Repository repository, Element enumElem,
             TextOutputInterface output, int depth,
             HashSet<String> uncheckedElem, String elementPath)
        {
            String enumNameNormalized = IDL_NormalizeUserDefinedClassifierName(enumElem.Name);
            output.OutputTextLine(depth,
                "enum " + enumNameNormalized + " {");

            //output.OutputTextLine(depth, "/* elementID = " + enumElem.ElementID + " */");
            GenIDL_EnumLiterals(repository, enumNameNormalized, enumElem, output, depth + 1);
            output.OutputTextLine(depth, "};");
        }

        private static bool GenIDL_MustGenerateClass(Repository repository, Element classElem,
             String elementPath, HashSet<String> uncheckedElem, HashSet<long> completedClasses)
        {
            // Check that it is a class
            if (!IsClass(classElem))
            {
                return false;
            }

            // If already generated skip class
            if ( (completedClasses != null) && completedClasses.Contains(classElem.ElementID) )
            {
                return false;
            }

            // If unchecked, skip class
            if (IsElementUnchecked(uncheckedElem, elementPath, classElem.Name))
            {
                return false;
            }

            return true;
        }

        private static void GenIDL_EmptyClassContent(String className,
            TextOutputInterface output, int depth)
        {
            output.OutputTextLine(depth, "octet __dummy_prevent_empty_class;");
        }

        private static void GenIDL_EmptyModuleContent(String moduleName,
            TextOutputInterface output, int depth)
        {
            output.OutputTextLine(depth, "const long EmptyModule_Sentinel_" + moduleName + " = 0;");
        }

        /**
         * Checks that all the definitions this class depends on are already generated
         * This includes the base classes as well as any types that appear as 
         * attributes and are not marked "@Shared"
         * 
         */
        private static bool GenIDL_DependenciesAlreadyGenerated(Repository repository, Element classElem,
            TextOutputInterface output, HashSet<long> completedClasses)
        {
            if (classElem.BaseClasses.Count > 0)
            {
                Object obj = classElem.BaseClasses.GetAt(0);
                Element elem = (Element)obj;
                if (!completedClasses.Contains(elem.ElementID))
                {
                    return false;
                }
            }

            return true;
        }

        private static void GenIDL_Class(Repository repository, Element classElem,
            TextOutputInterface output, int depth, 
            HashSet<String> uncheckedElem, String elementPath)
        {               
            String baseClassName = null;
            if (classElem.BaseClasses.Count > 0)
            {
                Object obj = classElem.BaseClasses.GetAt(0);
                Element elem = (Element)obj;
                baseClassName = GenIDL_GetFullPackageName(repository, elem) 
                    + IDL_NormalizeUserDefinedClassifierName(elem.Name);
            }

            String className = IDL_NormalizeUserDefinedClassifierName(classElem.Name); 
            output.OutputText(depth, "struct " + className);
            if (baseClassName != null)
            {
                output.OutputText(" : " + baseClassName);
            }
            output.OutputTextLine(" {");

            bool emptyClassContent = true;
            if (GenIDL_Attributes(repository, classElem, output, depth + 1))
            {
                emptyClassContent = false;
            }
            if (GenIDL_Relations(repository, classElem, output, depth + 1))
            {
                emptyClassContent = false;
            }
            
            if (emptyClassContent)
            {
                GenIDL_EmptyClassContent(className, output, depth + 1);
            }
            output.OutputText(depth, "};");


            string[] relevantAnnotationsNoValue = new string[] { 
                "autoid", 
                "final", "mutable", 
                "nested",
                "service"
            };
            string[] relevantAnnotationsWithValue = new string[] { 
                "Extensibility", "verbatim"
            };
            foreach (TaggedValue tag in classElem.TaggedValues)
            {
                String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name.ToLower());
                if (relevantAnnotationsNoValue.Contains(normalizedAnnotation))
                {
                    output.OutputText(depth, " //@" + normalizedAnnotation);
                }
                else if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                {
                    output.OutputText(depth, " //@" + normalizedAnnotation + " " + tag.Value);
                }
            }

            output.OutputTextLine();
        }


        private static char[] invalidTypenameChars = new char[] { ' ', '-', '&', '(', ')' };

        /**  Normalizes a user-defined UML classifier (class / package) name into a legal IDL class/module name
         * 
         */
        public static String IDL_NormalizeUserDefinedClassifierName(String classifierName)
        {
            for (int index = 0; index < invalidTypenameChars.GetLength(0); ++index) {
                classifierName = classifierName.Replace(invalidTypenameChars[index], '_');
            }

            return classifierName;
        }

        private static readonly string[] longlongTypes  = new string[] { "long long", "int64", "int64_t" };
        private static readonly string[] ulonglongTypes = new string[] { "unsigned long long", "uint64", "uint64_t" };
        private static readonly string[] longTypes      = new string[] { "long", "int", "int32", "int32_t", "integer", };
        private static readonly string[] ulongTypes     = new string[] { "unsigned long", "unsigned int", "ulong", "uint", "uint32", "uint32_t" };
        private static readonly string[] shortTypes     = new string[] { "short", "int16", "int16_t" };
        private static readonly string[] ushortTypes    = new string[] { "unsigned short", "ushort", "uint16", "uint16_t" };
        private static readonly string[] octetTypes     = new string[] { "octet", "byte", "int8", "int8_t", "uint8", "uint8_t" };
        private static readonly string[] floatTypes     = new string[] { "float", "float32", "number" };
        private static readonly string[] doubleTypes    = new string[] { "double", "float64" };

        private static readonly string[][] primtiveTypeVariations = {
            longlongTypes, ulonglongTypes, longTypes, ulongTypes, shortTypes, ushortTypes, octetTypes, floatTypes, doubleTypes };

        private static readonly Regex MultipleSpaces = new Regex(@" {2,}", RegexOptions.Compiled);

        /** Normalizes a type name converting it into a legal IDL4  type.
         *  
         * This function handles common variations of primitive type names. For anything non-primitive
         * it just calls IDL_NormalizeUserDefinedClassifierName
         */
        private static String IDL_NormalizeMemberTypeName(String typeName)
        {
            String normalizedType = MultipleSpaces.Replace(typeName, " ");
            for (int typeFamily = 0; typeFamily < primtiveTypeVariations.GetLength(0); ++typeFamily)
            {
                if (primtiveTypeVariations[typeFamily].Contains(normalizedType))
                {
                    return primtiveTypeVariations[typeFamily][0];
                }
            }

            return IDL_NormalizeUserDefinedClassifierName(normalizedType); 
        }


        private static readonly string[] keyAnnotation = new string[] { "Key", "key" };
        private static readonly string[] mustUnderstandAnnotation = new string[] { "must_understand" };

        private static readonly string[] idAnnotation = new string[] { "ID", "id" };
        private static readonly string[] autoidAnnotation = new string[] { "autoid" };
        private static readonly string[] optionalAnnotation = new string[] { "Optional", "optional" };
        private static readonly string[] valueAnnotation = new string[] { "value" };

        private static readonly string[] extensibilityAnnotation = new string[] { "Extensibility", "extensibility" };
        private static readonly string[] finalAnnotation = new string[] { "final" };
        private static readonly string[] mutableAnnotation = new string[] { "mutable" };

        private static readonly string[] defaultAnnotation = new string[] { "default" };
        private static readonly string[] rangeAnnotation = new string[] { "range" };
        private static readonly string[] minAnnotation = new string[] { "min" };
        private static readonly string[] maxAnnotation = new string[] { "max" };
        private static readonly string[] unitAnnotation = new string[] { "unit" };

        private static readonly string[] bitBoundAnnotation = new string[] { "bit_bound" };
        private static readonly string[] externalAnnotation = new string[] { "external" };
        private static readonly string[] nestedAnnotation = new string[] { "nested" };

        private static readonly string[] verbatimAnnotation = new string[] { "verbatim" };

        private static readonly string[] serviceAnnotation = new string[] { "service" };
        private static readonly string[] onewayAnnotation = new string[] { "oneway" };
        private static readonly string[] amiAnnotation = new string[]   { "ami" };



        private static readonly string[][] builtinAnnotationVariations = {
            keyAnnotation, mustUnderstandAnnotation,
            idAnnotation, autoidAnnotation, optionalAnnotation, valueAnnotation,
            extensibilityAnnotation, finalAnnotation, mutableAnnotation,
            defaultAnnotation, rangeAnnotation, minAnnotation, maxAnnotation, unitAnnotation,
            bitBoundAnnotation, externalAnnotation, nestedAnnotation,
            verbatimAnnotation,
            serviceAnnotation, onewayAnnotation, amiAnnotation
        };

        /** Normalizes an annotation type name converting it into a legal IDL4 / Connext DDS annotation.
         *  
         * This function handles common variations of capitalization for the builtin annotations. For anything 
         * non-built-in it just leaves it unchanged
         */
        private static String IDL_NormalizeAnnotationName(String annotationName)
        {
            String annotationNameLower = annotationName.ToLower();
            for (int annotationType = 0; annotationType < builtinAnnotationVariations.GetLength(0); ++annotationType)
            {
                if ( builtinAnnotationVariations[annotationType].Contains(annotationNameLower) )
                {
                    return builtinAnnotationVariations[annotationType][0];
                }
            }

            return annotationName;
        }

        /**
         * Determines whether this is a model element relevant to Connext DDS and we need to 
         * generate code associated with the model element.
         */
        private static bool IsClass(Element e)
        {
            return (e.Type == "Class");
        }

        private static bool IsEmptyClass(Element e)
        {
            return (e.Attributes.Count == 0) && (e.Connectors.Count == 0);
        }

    }
}
