/*********************************************************************************************
(c) 2005-2013 Copyright, Real-Time Innovations, Inc.  All rights reserved.    	                             
RTI grants Licensee a license to use, modify, compile, and create derivative works 
of the Software.  Licensee has the right to distribute object form only for use with RTI 
products.  The Software is provided “as is”, with no warranty of any type, including 
any warranty for fitness for any purpose. RTI is under no obligation to maintain or 
support the Software.  RTI shall not be liable for any incidental or consequential 
damages arising out of the use or inability to use the software.
**********************************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;


/* For the Sparx Automation APIs see:
 * http://bellekens.com/2011/01/29/tutorial-create-your-first-c-enterprise-architect-addin-in-10-minutes/
 * https://alexatnet.com/articles/creating-addin-for-sparx-enterprise-architect 
 * http://blog.sparxsystems.eu/2015/05/the-enterprise-architect-object-model-ea-api/ 
 * http://bellekens.com/writing-ea-add-ins/ 
 */

using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Drawing;
using EA;


namespace IDL4_EA_Extension
{
    public class IDLGenAction : UserActionInterface
    {
        private EA.Repository _currentRepository = null;
        private TextOutputInterface _currentOutput = null;
        private HashSet<string> _uncheckedElements = null;

        public void Initialize(EA.Repository repository, TextOutputInterface output, HashSet<string> uncheckedElements)
        {
            _currentRepository = repository;
            _currentOutput = output;
            _uncheckedElements = uncheckedElements;
        }

        public void OnCodegenAction()
        {
            Main.GenerateIDL(_currentRepository, _currentOutput, _uncheckedElements);
        }

        public void OnSaveAction(string filePath)
        {
            String[] preambleLines = {
               "/*",
               " *  IDL file generated by RTI Connext DDS Enterprise Architect IDL 4 Add-in version 1.0",
               " *      Enterprise Architect File:  " + _currentRepository.ConnectionString,
               " *      Date: " + DateTime.Now.ToString(),
               " */"
            };

            _currentOutput.SaveToFile(filePath, preambleLines);
        }

        public void OnSelectAction(TreeNode treeNode)
        {
            // OnDebugAction("Selected Node: " + treeNode.FullPath);
            Main.GenerateIDL_PreviewIDL(_currentRepository, _currentOutput, _uncheckedElements, treeNode.FullPath);
        }

        public void OnCheckAction(TreeNode treeNode)
        {
            // Remember whether it is uncheked or not
            if (treeNode.Checked)
            {
                _uncheckedElements.Remove(treeNode.FullPath);
            }
            else
            {
                _uncheckedElements.Add(treeNode.FullPath);
            }
        }

        public void OnDebugAction(string text)
        {
            _currentOutput.OutputTextLine(text);
        }
    }

    [ComVisible(true)]
    public class Main 
    {

        private const String MENU_ROOT_RTI_CONNEXT  = "- IDL4  (RTI Connext DDS)";
        private const String MENU_ITEM_GENERATE_XML = "Generate IDL ...";

        // Called Before EA starts to check Add-In Exists
        public string EA_Connect(Repository repository)
        {
            // nothing special
            return "EaProjectStats.AddIn - connected";
        }
        // EA calls this operation when it exists. Can be used to do some cleanup work.
        public void EA_Disconnect()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }

        // Called when user Click Add-Ins Menu item.
        public object EA_GetMenuItems(Repository repository,
            string location, string menuName)
        {
            switch (menuName)
            {
                case "":
                    return MENU_ROOT_RTI_CONNEXT;
                case MENU_ROOT_RTI_CONNEXT:
                    return MENU_ITEM_GENERATE_XML;
            }
            return "";
        }

        // Sets the state of the menu depending if there is
        // an active project or not
        static bool EA_IsProjectOpen(Repository repository)
        {
            try
            {
                return null != repository.Models;
            }
            catch
            {
                return false;
            }
        }

        // Called once Menu has been opened to see what menu
        // items are active.
        public void EA_GetMenuState(Repository repository,
            string location, string menuName, string itemName,
            ref bool isEnabled, ref bool isChecked)
        {
            if (EA_IsProjectOpen(repository))
            {
                if (itemName == MENU_ROOT_RTI_CONNEXT)
                    isEnabled = true;
            }
            else
                // If no open project, disable all menu options
                isEnabled = false;
        }


        // Called when user makes a selection in the menu.
        // This is your main exit point to the rest of your Add-in
        public void EA_MenuClick(Repository repository,
            string location, string menuName, string itemName)
        {

            switch (itemName)
            {
                case MENU_ITEM_GENERATE_XML:
                    IDLGenAction idlGenAction = new IDLGenAction();
                    IDLClassSelector idlClassSelector = new IDLClassSelector(idlGenAction);
                    TextBoxOutputAdapter output = new TextBoxOutputAdapter(idlClassSelector.getTextBox());
                    HashSet<string> uncheckedElements = new HashSet<string>();
                    idlGenAction.Initialize(repository, output, uncheckedElements);

                   // GenerateIDL(repository, output);

                    PopulateClassSelector(idlClassSelector, repository);
                    idlClassSelector.Text = "IDL4 (RTI Connext DDS) - Select classes for IDL generation"; 
                    idlClassSelector.Show();
                    //idlGenAction.OnCodegenAction();
                    break;
            }
        }

        public static void PopulateClassSelector(IDLClassSelector classSelector, Repository repository)
        {
            TreeNodeCollection treeNodes = classSelector.getTreeView().Nodes;

            foreach (Package model in repository.Models)
            {
                TreeNode newNode = new TreeNode(model.Name);
                newNode.Checked = true;
                newNode.Expand();
                treeNodes.Add(newNode);

                foreach (Package package in model.Packages)
                {
                    PopulateClassSelector(newNode, package);
                }
            }
        }

        public static void PopulateClassSelector(TreeNode parentNode, Package package)
        {
            TreeNode packageNode = new TreeNode(package.Name);
            packageNode.Checked = true;
            packageNode.Expand();
            parentNode.Nodes.Add(packageNode);


            foreach (Element e in package.Elements)
            {
                if (GenerateIDL_IsRelevantClass(e))
                {
                    TreeNode classNode = new TreeNode(e.Name);
                    classNode.Checked = true;
                    packageNode.Nodes.Add(classNode);
                }
            } 

            foreach (Package p in package.Packages)
            {
                PopulateClassSelector(packageNode, p);
            }
        }

        /** Finds a child of an EA Model element capturing exceptions raised if the child is not
         * found.
         * 
         */
        private static Object GenerateIDL_FindChild(EA.Collection collection, String childName)
        {
            Object child = null;
            try {
                child = collection.GetByName(childName);
            }
            catch (Exception) {}

            return child;
        }

        internal static void GenerateIDL_PreviewIDL(Repository repository, TextOutputInterface output, HashSet<string> uncheckedElem, String fullPath)
        {
            char[] delimiterChars = { '\\'};
            String[] elementNames = fullPath.Split(delimiterChars);

            Package package = (Package)GenerateIDL_FindChild(repository.Models, elementNames[0]);
            //Package model = (Package)repository.Models.GetByName(elementNames[0]);
            if (package == null)
            {
                output.OutputTextLine("Could not find selected model: \"" + fullPath + "\" in the model");
                return;
            }

            Package parentPackage = package;
            Element  classElem = null;
            for (int i = 1; i < elementNames.Length; ++i, parentPackage = package)
            {
                String elemName = elementNames[i];

                package = (Package)GenerateIDL_FindChild(parentPackage.Packages, elemName);
                //package = (Package)parentPackage.Packages.GetByName(elemName);

                if ((package == null) && (i == elementNames.Length - 1))
                {
                    classElem = (Element)GenerateIDL_FindChild(parentPackage.Elements, elemName);
                }
            }

            output.Clear();
            if (package == null && classElem == null)
            {
                output.OutputTextLine("Could not find selected element: \"" + fullPath + "\" in the model");
                return;
            }

            for (int i = 0; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("module " + IDL_NormalizeUserDefinedClassifierName(elementNames[i]) + " {  ");
            }
            if (package != null)
            {
                // display package
                // output.OutputTextLine("Displaying Package: " + package.Name);
                Main.GenerateIDL_Module(repository, package, output, 0, null, null);
            }
            else if (classElem != null)
            {
                // display class
                // output.OutputTextLine("Displaying Class: " + classElem.Name);
                Main.GenerateIDL_Class(repository, classElem, output, 1, null, "");
            }
            for (int i = 0; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("};  ");
            }
        }

        internal static void GenerateIDL(Repository repository, TextOutputInterface output, HashSet<String> uncheckedElem)
        {
            output.Clear();
            foreach (Package model in repository.Models)
            {
                if (uncheckedElem.Contains(model.Name) )
                {
                    // if unckecked skip this model
                    continue;
                }

                foreach (Package package in model.Packages)
                {
                    GenerateIDL_Module(repository, package, output, 0, uncheckedElem, model.Name);
                }
            }
        }

        /** Generate IDL4 module corresponding to the UML package
         * 
         *  This function is recursive. It generates IDl for all the nested UML packages and classes
         */
        private static void GenerateIDL_Module(Repository repository, Package package, 
            TextOutputInterface output, int depth, 
            HashSet<String> uncheckedElem, String pathToElem)
        {
            // if unckecked skip this model
            String packageFullName = GenerateIDL_FullElementName(pathToElem, package.Name);
            if (GenerateIDL_IsElementUnchecked(uncheckedElem, packageFullName)) 
            {   
                return;
            }

            output.OutputTextLine(depth, "module " + IDL_NormalizeUserDefinedClassifierName(package.Name) + " {");

            
            // Experimentally I determined that the package.Elements collection does not contain sub-packages
            // So we iterate separately over the nested packages and the nested classes
            foreach (Element e in package.Elements)
            {
                if (GenerateIDL_IsRelevantClass(e) )
                {
                    GenerateIDL_Class(repository, e, output, depth + 1, uncheckedElem, packageFullName);
                }
            }
            
            foreach (Package p in package.Packages)
            {
                GenerateIDL_Module(repository, p, output, depth + 1, uncheckedElem, packageFullName);
            }

            output.OutputTextLine(depth, "};");
        }


        /* Generate the IDL for an attribute.
         * The atribute can appear by itself, a sequence, or an array.
         * The determinaton of this is based on the settings of LowerBound and UpperBound
         *    
         *    UpperBound == 0                 ==>  Unbounded Sequence
         *    LowerBound == UpperBound == 1        ==>  Single member (no Array/Sequence)
         *    LowerBound == 0 && UpperBound == 1   ==>  Optional single member
         *    
         *    LowerBound  < UpperBound  (other values)    ==>  Bounded Sequence
         *    LowerBound == UpperBound  (other values)    == > Array
         */
        private static void GenerateIDL_Attributes(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {

            foreach (EA.Attribute child in classElem.Attributes)
            {
                String typeName = IDL_NormalizeMemberTypeName(child.Type);

                // textForm.getTextBox().AppendText("    " + typeName + "  "
                //       + child.Name + " lower: " + child.LowerBound + "  upper: " + child.UpperBound + Environment.NewLine);

                int lower  = Convert.ToInt32(child.LowerBound);
                int upper = Convert.ToInt32(child.UpperBound);

                if (upper == 0) // Unbounded sequence
                {
                    output.OutputText(depth, "sequence<" + typeName + "> " + child.Name + ";");
                }
                else if (lower == upper)
                {
                    if (upper == 1) // Single member
                    {
                        output.OutputText(depth, typeName + "  " + child.Name + ";" );
                    }
                    else // Array
                    {
                        output.OutputText(depth, typeName + " " + child.Name + "[" + child.UpperBound + "];");
                    }
                }
                else if (lower == 0 && upper == 1) // optional
                {
                    output.OutputText(depth, typeName + " " + child.Name + "; //@optional");
                }
                else // bounded sequence
                {
                    output.OutputText(depth, "sequence<" + typeName + "," + child.UpperBound + "> "
                        + child.Name + " ;");
                }

                string[] relevantAnnotationsNoValue = new string[] { "key", "optional" };
                foreach (AttributeTag tag in child.TaggedValues)
                {
                    if ( relevantAnnotationsNoValue.Contains(tag.Name.ToLower()) ) 
                    {
                        output.OutputText(" //@" + tag.Name.ToLower());
                    }
                }
                output.OutputTextLine();
            }
        }

        private static String GenerateIDL_GetReferencedTypeToInclude(Repository repository, Element classElem, EA.Connector conn )
        {
            string[] relevantConnectorTypes = new string[] { "Aggregation", "Association" };
            if (!relevantConnectorTypes.Contains(conn.Type))
            {
                return null;
            }
            
            ConnectorEnd target = conn.SupplierEnd;
            ConnectorEnd source = conn.ClientEnd;

            if (classElem.ElementID == conn.ClientID)
            {
                // We are source of relationship
                if ( (source.Aggregation != 0)
                    && (            
                        conn.Direction.Equals("Source -> Destination") ||
                        conn.Direction.Equals("Bi-Directional"))
                    )
                {
                    return repository.GetElementByID(conn.SupplierID).Name;
                }
            }
            else
            {
                // We are target of relationship
                if ( (target.Aggregation != 0)
                    && (            
                        conn.Direction.Equals("Destination -> Source") ||
                        conn.Direction.Equals("Bi-Directional"))
                    )
                {
                    return repository.GetElementByID(conn.ClientID).Name;
                }

            }

            return null;
        }

        private static void GenerateIDL_Relations(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            foreach (EA.Connector conn in classElem.Connectors)
            {
                String referencedType = GenerateIDL_GetReferencedTypeToInclude(repository, classElem, conn);
                // textForm.getTextBox().AppendText("    type: " + conn.Type  + Environment.NewLine);

                if (referencedType != null)
                {
                    String connName = conn.Name;
                    output.OutputTextLine(depth, referencedType + "  " + connName + ";");
                }
            }
        }

        private static String GenerateIDL_FullElementName(String elementPath, String elementName)
        {
            return elementPath + "\\" + elementName;
        }

        private static bool GenerateIDL_IsElementUnchecked(HashSet<String> uncheckedElem, String elementFullName) 
        {
            return (uncheckedElem != null) && (uncheckedElem.Contains(elementFullName));
        }

        private static bool GenerateIDL_IsElementUnchecked(HashSet<String> uncheckedElem, String elementPath, String elementName)
        {
            if (uncheckedElem == null)
            {
                return false;
            }
            return uncheckedElem.Contains(GenerateIDL_FullElementName(elementPath, elementName));
        }
    
        private static void GenerateIDL_Class(Repository repository, Element classElem,
            TextOutputInterface output, int depth, 
            HashSet<String> uncheckedElem, String elementPath)
        {
            // If unchecked, skip class
            if (GenerateIDL_IsElementUnchecked(uncheckedElem, elementPath, classElem.Name))
            {  
                return;
            }

            String baseClassName = null;
            if (classElem.BaseClasses.Count > 0)
            {
                Object obj = classElem.BaseClasses.GetAt(0);
                Element elem = (Element)obj;
                baseClassName = elem.Name;
            }

            output.OutputText(depth, "struct " + IDL_NormalizeUserDefinedClassifierName(classElem.Name));
            if (baseClassName != null)
            {
                output.OutputText(" : " + IDL_NormalizeUserDefinedClassifierName(baseClassName));
            }
            output.OutputTextLine(" {");

            GenerateIDL_Attributes(repository, classElem, output, depth+1);
            GenerateIDL_Relations(repository, classElem, output, depth+1);

            output.OutputText(depth, "};");

            string[] relevantAnnotationsOneValue = new string[] { "extensibility" };
            foreach (TaggedValue tag in classElem.TaggedValues)
            {
                if (relevantAnnotationsOneValue.Contains(tag.Name.ToLower()))
                {
                    output.OutputText(depth, " //@" + tag.Name.ToLower() + "( " + tag.Value + ")");
                }
            }

            output.OutputTextLine();
        }


        /**  Normalizes a user-defined UML classifier (class / package) name into a legal IDL class/module name
         * 
         */
        public static String IDL_NormalizeUserDefinedClassifierName(String classifierName)
        {
            return classifierName.Replace(" ", "_");
        }

        private static readonly string[] longlongTypes  = new string[] { "long long", "int64", "int64_t" };
        private static readonly string[] ulonglongTypes = new string[] { "unsigned long long", "uint64", "uint64_t" };
        private static readonly string[] longTypes      = new string[] { "long", "int", "int32", "int32_t", "integer", };
        private static readonly string[] ulongTypes     = new string[] { "unsigned long", "unsigned int", "ulong", "uint", "uint32", "uint32_t" };
        private static readonly string[] shortTypes     = new string[] { "short", "int16", "int16_t" };
        private static readonly string[] ushortTypes    = new string[] { "unsigned short", "ushort", "uint16", "uint16_t" };
        private static readonly string[] octetTypes     = new string[] { "octet", "byte", "int8", "int8_t", "uint8", "uint8_t" };
        private static readonly string[] floatTypes     = new string[] { "float", "float32", "number" };
        private static readonly string[] doubleTypes    = new string[] { "double", "float64" };
        private static readonly Regex MultipleSpaces = new Regex(@" {2,}", RegexOptions.Compiled);

        /** Normalizes a type name converting it into a legal IDL4  type.
         *  
         * This function handles common variations of primitive type names. For anything non-primitive
         * it just calls IDL_NormalizeUserDefinedClassifierName
         */
        private static String IDL_NormalizeMemberTypeName(String typeName)
        {
            String normalizedType = MultipleSpaces.Replace(typeName, " ");

            if (longlongTypes.Contains(normalizedType))
            {
                return longlongTypes[0];
            }
            else if (ulonglongTypes.Contains(normalizedType))
            {
                return ulonglongTypes[0];
            }
            else if (longTypes.Contains(normalizedType))
            {
                return longTypes[0];
            }
            else if (ulongTypes.Contains(normalizedType))
            {
                return ulongTypes[0];
            }
            else if (shortTypes.Contains(normalizedType))
            {
                return shortTypes[0];
            }
            else if (ushortTypes.Contains(normalizedType))
            {
                return ushortTypes[0];
            }
            else if (octetTypes.Contains(normalizedType))
            {
                return octetTypes[0];
            }
            else 
            {
                return IDL_NormalizeUserDefinedClassifierName(normalizedType);
            }
        }

        /**
         * Returns all the model elements in the package for which we need to generate
         * Connnext data-classes (IDL) code 
         * 
         * Currently the determination of whether to select a model element for IDL
         * code generation os based on having a "pure data-class" that is a class with no
         * operations.
         */
        private static List<Element> GetConnextCodegenClasses(Package package)
        {
            List<Element> classList = new List<Element>();
            foreach (Element e in package.Elements)
            {
                if (GenerateIDL_IsRelevantClass(e) )
                {
                    classList.Add(e);
                }
            }
            foreach (Package p in package.Packages)
            {
                classList.AddRange(GetConnextCodegenClasses(p));
            }
            return classList;
        }


        /**
         * Determines whether this is a model element relevant to Connext DDS and we need to 
         * generate code associated with the model element.
         */
        private static bool GenerateIDL_IsRelevantClass(Element e)
        {
            return (e.Type == "Class") && (e.Methods.Count == 0);
        }

    }
}
