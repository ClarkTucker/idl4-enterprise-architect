/*********************************************************************************************
(c) 2005-2015 Copyright, Real-Time Innovations, Inc.  All rights reserved. 
RTI grants Licensee a license to use, modify, compile, and create derivative works 
of the Software.  Licensee has the right to distribute object form only for use with RTI 
products.  The Software is provided “as is”, with no warranty of any type, including 
any warranty for fitness for any purpose. RTI is under no obligation to maintain or 
support the Software.  RTI shall not be liable for any incidental or consequential 
damages arising out of the use or inability to use the software.
**********************************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;


/* For the Sparx Automation APIs see:
 * http://bellekens.com/2011/01/29/tutorial-create-your-first-c-enterprise-architect-addin-in-10-minutes/
 * https://alexatnet.com/articles/creating-addin-for-sparx-enterprise-architect 
 * http://blog.sparxsystems.eu/2015/05/the-enterprise-architect-object-model-ea-api/ 
 * http://bellekens.com/writing-ea-add-ins/ 
 */

using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Drawing;
using EA;

namespace IDL4_EA_Extension
{
    public class IDLGenAction : UserActionInterface
    {
        private EA.Repository _currentRepository = null;
        private TextOutputInterface _currentOutput = null;
        private HashSet<string> _uncheckedElements = null;

        public void Initialize(EA.Repository repository, TextOutputInterface output, HashSet<string> uncheckedElements)
        {
            _currentRepository = repository;
            _currentOutput = output;
            _uncheckedElements = uncheckedElements;
        }

        public void OnCodegenAction()
        {
            Main.GenIDL(_currentRepository, _currentOutput, _uncheckedElements);
        }

        public void OnSaveAction(string filePath)
        {
            String[] preambleLines = {
               "/*",
               " *  IDL file generated by RTI Connext DDS Enterprise Architect IDL 4 Add-in version 1.0",
               " *      Enterprise Architect File:  " + _currentRepository.ConnectionString,
               " *      Date: " + DateTime.Now.ToString(),
               " */"
            };

            _currentOutput.SaveToFile(filePath, preambleLines);
        }

        public void OnSelectAction(TreeNode treeNode)
        {
            // OnDebugAction("Selected Node: " + treeNode.FullPath);
            Main.GenIDL_Preview(_currentRepository, _currentOutput, _uncheckedElements, treeNode.FullPath);
        }

        public void OnCheckAction(TreeNode treeNode)
        {
            // Remember whether it is uncheked or not
            if (treeNode.Checked)
            {
                _uncheckedElements.Remove(treeNode.FullPath);
            }
            else
            {
                _uncheckedElements.Add(treeNode.FullPath);
            }
        }

        public void OnDebugAction(string text)
        {
            _currentOutput.OutputTextLine(text);
        }
    }

    [ComVisible(true)]
    public class Main 
    {

        private const String MENU_ROOT_RTI_CONNEXT  = "- IDL4  (RTI Connext DDS)";
        private const String MENU_ITEM_GENERATE_XML = "Generate IDL ...";

        // Called Before EA starts to check Add-In Exists
        public string EA_Connect(Repository repository)
        {
            // nothing special
            return "EaProjectStats.AddIn - connected";
        }
        // EA calls this operation when it exists. Can be used to do some cleanup work.
        public void EA_Disconnect()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }

        // Called when user Click Add-Ins Menu item.
        public object EA_GetMenuItems(Repository repository,
            string location, string menuName)
        {
            switch (menuName)
            {
                case "":
                    return MENU_ROOT_RTI_CONNEXT;
                case MENU_ROOT_RTI_CONNEXT:
                    return MENU_ITEM_GENERATE_XML;
            }
            return "";
        }

        // Sets the state of the menu depending if there is
        // an active project or not
        static bool EA_IsProjectOpen(Repository repository)
        {
            try
            {
                return null != repository.Models;
            }
            catch
            {
                return false;
            }
        }

        // Called once Menu has been opened to see what menu
        // items are active.
        public void EA_GetMenuState(Repository repository,
            string location, string menuName, string itemName,
            ref bool isEnabled, ref bool isChecked)
        {
            if (EA_IsProjectOpen(repository))
            {
                if (itemName == MENU_ROOT_RTI_CONNEXT)
                    isEnabled = true;
            }
            else
                // If no open project, disable all menu options
                isEnabled = false;
        }


        // Called when user makes a selection in the menu.
        // This is your main exit point to the rest of your Add-in
        public void EA_MenuClick(Repository repository,
            string location, string menuName, string itemName)
        {

            switch (itemName)
            {
                case MENU_ITEM_GENERATE_XML:
                    IDLGenAction idlGenAction = new IDLGenAction();
                    IDLClassSelector idlClassSelector = new IDLClassSelector(idlGenAction);
                    TextBoxOutputAdapter output = new TextBoxOutputAdapter(idlClassSelector.getTextBox());
                    HashSet<string> uncheckedElements = new HashSet<string>();
                    idlGenAction.Initialize(repository, output, uncheckedElements);

                   // GenerateIDL(repository, output);

                    PopulateClassSelector(idlClassSelector, repository);
                    idlClassSelector.Text = "IDL4 (RTI Connext DDS) - Select classes for IDL generation"; 
                    idlClassSelector.Show();
                    //idlGenAction.OnCodegenAction();
                    break;
            }
        }

        public static void PopulateClassSelector(IDLClassSelector classSelector, Repository repository)
        {
            TreeNodeCollection treeNodes = classSelector.getTreeView().Nodes;

            foreach (Package model in repository.Models)
            {
                TreeNode newNode = new TreeNode(model.Name);
                newNode.Checked = true;
                newNode.Expand();
                treeNodes.Add(newNode);

                foreach (Package package in model.Packages)
                {
                    PopulateClassSelector(newNode, package);
                }
            }
        }

        public static void PopulateClassSelector(TreeNode parentNode, Package package)
        {
            TreeNode packageNode = new TreeNode(package.Name);
            packageNode.Checked = true;
            packageNode.Expand();
            parentNode.Nodes.Add(packageNode);


            foreach (Element e in package.Elements)
            {
                if (IsRelevantClass(e))
                {
                    TreeNode classNode = new TreeNode(e.Name);
                    classNode.Checked = true;
                    packageNode.Nodes.Add(classNode);
                }
            } 

            foreach (Package p in package.Packages)
            {
                PopulateClassSelector(packageNode, p);
            }
        }

        /** Finds a child of an EA Model element capturing exceptions raised if the child is not
         * found.
         * 
         */
        private static Object EAUtil_FindChild(EA.Collection collection, String childName)
        {
            Object child = null;
            try {
                child = collection.GetByName(childName);
            }
            catch (Exception) {}

            return child;
        }

        internal static void GenIDL_Preview(Repository repository, TextOutputInterface output, HashSet<string> uncheckedElem, String fullPath)
        {
            char[] delimiterChars = { '\\'};
            String[] elementNames = fullPath.Split(delimiterChars);

            Package package = (Package)EAUtil_FindChild(repository.Models, elementNames[0]);
            //Package model = (Package)repository.Models.GetByName(elementNames[0]);
            if (package == null)
            {
                output.OutputTextLine("Could not find selected model: \"" + fullPath + "\" in the model");
                return;
            }

            Package parentPackage = package;
            Element  classElem = null;
            for (int i = 1; i < elementNames.Length; ++i, parentPackage = package)
            {
                String elemName = elementNames[i];

                package = (Package)EAUtil_FindChild(parentPackage.Packages, elemName);
                //package = (Package)parentPackage.Packages.GetByName(elemName);

                if ((package == null) && (i == elementNames.Length - 1))
                {
                    classElem = (Element)EAUtil_FindChild(parentPackage.Elements, elemName);
                }
            }

            output.Clear();
            if (package == null && classElem == null)
            {
                output.OutputTextLine("Could not find selected element: \"" + fullPath + "\" in the model");
                return;
            }

            for (int i = 0; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("module " + IDL_NormalizeUserDefinedClassifierName(elementNames[i]) + " {  ");
            }
            output.OutputTextLine();
            if (package != null)
            {
                // display package
                // output.OutputTextLine("Displaying Package: " + package.Name);
                Main.GenIDL_Module(repository, package, output, elementNames.Length - 1, null, null);
            }
            else if (classElem != null)
            {
                // display class
                // output.OutputTextLine("Displaying Class: " + classElem.Name);
                if (IsElementEnum(classElem))
                {
                    Main.GenIDL_Enum(repository, classElem, output, elementNames.Length - 1, null, "");
                }
                else
                {
                    Main.GenIDL_Class(repository, classElem, output, elementNames.Length - 1, null, "");
                }
            }
            for (int i = 0; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("};");
            }
        }

        /** Outputs UML "primitive" types that are not primitive in IDL
         */
        private static void GenIDL_PrebuiltUMLTypes(TextOutputInterface output)
        {
            String builtinTypes = 
                "struct dateTime { long date; long time; };";
            output.OutputTextLine(builtinTypes);
        }

        internal static void GenIDL(Repository repository, TextOutputInterface output, HashSet<String> uncheckedElem)
        {
            output.Clear();

            output.OutputTextLine("/* ******************************************************************* */");
            output.OutputTextLine("/* These are UML builtin primitive types that are not primitive in IDL */");
            GenIDL_PrebuiltUMLTypes(output);
            output.OutputTextLine("");

            output.OutputTextLine("/* ******************************************************************* */");
            output.OutputTextLine("/* These are Types defined in the model */");
            output.OutputTextLine("");

            foreach (Package model in repository.Models)
            {
                if (uncheckedElem.Contains(model.Name) )
                {
                    // if unckecked skip this model
                    continue;
                }

                foreach (Package package in model.Packages)
                {
                    GenIDL_Module(repository, package, output, 0, uncheckedElem, model.Name);
                }
            }
        }

        /** Generate IDL4 module corresponding to the UML package
         * 
         *  This function is recursive. It generates IDl for all the nested UML packages and classes
         */
        private static void GenIDL_Module(Repository repository, Package package, 
            TextOutputInterface output, int depth, 
            HashSet<String> uncheckedElem, String pathToElem)
        {
            // if unckecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if (IsElementUnchecked(uncheckedElem, packageFullName)) 
            {   
                return;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);
            output.OutputTextLine(depth, "module " + moduleName + " {");

            //TODO: Temporary solution. To avoid problems with empty modules without analyzing the module
            //      first we always emit some declaration in the module
            output.OutputTextLine(depth + 1, "enum DUMMY_AvoidEmptyModule { DUMMY_DoNotUse };");


            
            // Experimentally I determined that the package.Elements collection does not contain sub-packages
            // So we iterate separately over the nested packages and the nested classes
            foreach (Element e in package.Elements)
            {
                if (IsElementEnum(e))
                {
                    GenIDL_Enum(repository, e, output, depth + 1, uncheckedElem, packageFullName);
                }
                else {
                    GenIDL_Class(repository, e, output, depth + 1, uncheckedElem, packageFullName);
                }
            }
            
            foreach (Package p in package.Packages)
            {
                GenIDL_Module(repository, p, output, depth + 1, uncheckedElem, packageFullName);
            }

            output.OutputTextLine(depth, "}; /* end module " + moduleName + " */");
        }


        /* Generate the IDL for an enum literal.
         */
        private static void GenIDL_EnumLiterals(Repository repository, Element enumElem, TextOutputInterface output, int depth)
        {
            short childCount = enumElem.Attributes.Count;
            for (short i = 0 ; i < childCount; ++i ) 
            {
                EA.Attribute child = enumElem.Attributes.GetAt(i);
                String typeName = IDL_NormalizeMemberTypeName(child.Type);
                if (i < childCount - 1)
                {
                    output.OutputText(depth, typeName + "  " + child.Name + ",");
                }
                else
                {
                    output.OutputText(depth, typeName + "  " + child.Name);
                }

                string[] relevantAnnotationsWithValue = new string[] {
                    "ID", "Value"
                };
                foreach (AttributeTag tag in child.TaggedValues)
                {
                    String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);
                    if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                    {
                        output.OutputText(" //@" + normalizedAnnotation + " " + tag.Value);
                    }
                }

                output.OutputTextLine();
            }
        }

        private static String GenIDL_GetFullPackageName(Repository repository, Element elem)
        {
            String packageName = "";
            int packageID = elem.PackageID;
            Package package = repository.GetPackageByID(packageID);
            int parentPackageID = package.ParentID;

            while (parentPackageID != 0)
            {
                packageName = IDL_NormalizeUserDefinedClassifierName(package.Name) + "::" + packageName;
                packageID = parentPackageID;
                package = repository.GetPackageByID(packageID);
                parentPackageID = package.ParentID;
            }

            return packageName;
        }

        /* Generate the IDL for an attribute.
         * The atribute can appear by itself, a sequence, or an array.
         * The determinaton of this is based on the settings of LowerBound and UpperBound
         *    
         *    UpperBound == 0                 ==>  Unbounded Sequence
         *    LowerBound == UpperBound == 1        ==>  Single member (no Array/Sequence)
         *    LowerBound == 0 && UpperBound == 1   ==>  Optional single member
         *    
         *    LowerBound  < UpperBound  (other values)    ==>  Bounded Sequence
         *    LowerBound == UpperBound  (other values)    == > Array
         */
        private static void GenIDL_Attributes(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            //TODO: Empty classes are not legal IDL. So if class is empty add some dummy element
            if (classElem.Attributes.Count == 0)
            {
                output.OutputTextLine(depth, "octet __dummy_prevent_emty_struct;");
                return;
            }


            foreach (EA.Attribute child in classElem.Attributes)
            {
                // This does not get the fully qualified type name. We need that to fully resolve
                // the type in the IDL...
                String typeName;
                
                /* This code was trying to get the fully-qualified name but it throws an exception
                 */
                if ( child.ClassifierID == 0 ) {
                    typeName = IDL_NormalizeMemberTypeName(child.Type);
                }
                else {
                    Element attributeType = repository.GetElementByID(child.ClassifierID);
                    Package attributePackage = repository.GetPackageByID(attributeType.PackageID);
                    typeName = GenIDL_GetFullPackageName(repository, attributeType) 
                        + IDL_NormalizeMemberTypeName(attributeType.Name);
                }

                // output.OutputText(depth, "/* child.ClassifierID = " + child.ClassifierID + " */");

                int lower  = Convert.ToInt32(child.LowerBound);
                int upper = Convert.ToInt32(child.UpperBound);

                if (upper == 0) // Unbounded sequence
                {
                    output.OutputText(depth, "sequence<" + typeName + "> " + child.Name + ";");
                }
                else if (lower == upper)
                {
                    if (upper == 1) // Single member
                    {
                        output.OutputText(depth, typeName + "  " + child.Name + ";" );
                    }
                    else // Array
                    {
                        output.OutputText(depth, typeName + " " + child.Name + "[" + child.UpperBound + "];");
                    }
                }
                else if (lower == 0 && upper == 1) // optional
                {
                    output.OutputText(depth, typeName + " " + child.Name + "; //@Optional");
                }
                else // bounded sequence
                {
                    output.OutputText(depth, "sequence<" + typeName + "," + child.UpperBound + "> "
                        + child.Name + " ;");
                }
                
                string[] relevantAnnotationsNoValue = new string[] {
                    "Key", "must_understand",
                    "autoid", "Optional",
                    "external", "nested",
                    "oneway", "ami"
                };
                string[] relevantAnnotationsWithValue = new string[] {
                    "ID", "Value"
                };
                foreach (AttributeTag tag in child.TaggedValues)
                {
                    String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);
                    if ( relevantAnnotationsNoValue.Contains(normalizedAnnotation) ) 
                    {
                        output.OutputText(" //@" + normalizedAnnotation);
                    }
                    else if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                    {
                        output.OutputText(" //@" + normalizedAnnotation + " " + tag.Value);
                    }
                }

                output.OutputTextLine();
            }
        }

        private static String GenIDL_GetReferencedTypeToInclude(Repository repository, Element classElem, EA.Connector conn )
        {
            string[] relevantConnectorTypes = new string[] { "Aggregation", "Association" };
            if (!relevantConnectorTypes.Contains(conn.Type))
            {
                return null;
            }
            
            ConnectorEnd target = conn.SupplierEnd;
            ConnectorEnd source = conn.ClientEnd;

            if (classElem.ElementID == conn.ClientID)
            {
                // We are source of relationship
                if ( (source.Aggregation != 0)
                    && (            
                        conn.Direction.Equals("Source -> Destination") ||
                        conn.Direction.Equals("Bi-Directional"))
                    )
                {
                    return repository.GetElementByID(conn.SupplierID).Name;
                }
            }
            else
            {
                // We are target of relationship
                if ( (target.Aggregation != 0)
                    && (            
                        conn.Direction.Equals("Destination -> Source") ||
                        conn.Direction.Equals("Bi-Directional"))
                    )
                {
                    return repository.GetElementByID(conn.ClientID).Name;
                }

            }

            return null;
        }

        private static void GenIDL_Relations(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            foreach (EA.Connector conn in classElem.Connectors)
            {
                String referencedType = GenIDL_GetReferencedTypeToInclude(repository, classElem, conn);
                // textForm.getTextBox().AppendText("    type: " + conn.Type  + Environment.NewLine);

                if (referencedType != null)
                {
                    String connName = conn.Name;
                    output.OutputTextLine(depth, referencedType + "  " + connName + ";");
                }
            }
        }

        private static String IDL_FullElementName(String elementPath, String elementName)
        {
            return elementPath + "\\" + elementName;
        }

        private static bool IsElementUnchecked(HashSet<String> uncheckedElem, String elementFullName) 
        {
            return (uncheckedElem != null) && (uncheckedElem.Contains(elementFullName));
        }

        private static bool IsElementUnchecked(HashSet<String> uncheckedElem, String elementPath, String elementName)
        {
            if (uncheckedElem == null)
            {
                return false;
            }
            return uncheckedElem.Contains(IDL_FullElementName(elementPath, elementName));
        }

        private static bool IsElementEnum(Element elem)
        {
            // TODO
            return elem.Stereotype.Equals("enumeration");
        }

        private static void GenIDL_Enum(Repository repository, Element enumElem,
             TextOutputInterface output, int depth,
             HashSet<String> uncheckedElem, String elementPath)
        {
            output.OutputTextLine(depth,
                "enum " + IDL_NormalizeUserDefinedClassifierName(enumElem.Name) + " {");

            //output.OutputTextLine(depth, "/* elementID = " + enumElem.ElementID + " */");
            GenIDL_EnumLiterals(repository, enumElem, output, depth + 1);
            output.OutputTextLine(depth, "};");
        }

        private static void GenIDL_Class(Repository repository, Element classElem,
            TextOutputInterface output, int depth, 
            HashSet<String> uncheckedElem, String elementPath)
        {
            // If unchecked, skip class
            if (IsElementUnchecked(uncheckedElem, elementPath, classElem.Name))
            {  
                return;
            }
            // Check that the class is relevant meaning for example that it has members
            if (!IsRelevantClass(classElem))
            {
                return;
            }
                

            String baseClassName = null;
            if (classElem.BaseClasses.Count > 0)
            {
                Object obj = classElem.BaseClasses.GetAt(0);
                Element elem = (Element)obj;
                baseClassName = GenIDL_GetFullPackageName(repository, elem) 
                    + IDL_NormalizeUserDefinedClassifierName(elem.Name);
            }

            output.OutputText(depth, "struct " + IDL_NormalizeUserDefinedClassifierName(classElem.Name));
            if (baseClassName != null)
            {
                output.OutputText(" : " + baseClassName);
            }
            output.OutputTextLine(" {");
            // output.OutputTextLine(depth, "/* elementID = " + classElem.ElementID + " */");


            GenIDL_Attributes(repository, classElem, output, depth+1);
            GenIDL_Relations(repository, classElem, output, depth+1);

            output.OutputText(depth, "};");


            string[] relevantAnnotationsNoValue = new string[] { 
                "autoid", 
                "final", "mutable", 
                "nested",
                "service"
            };
            string[] relevantAnnotationsWithValue = new string[] { 
                "Extensibility", "verbatim"
            };
            foreach (TaggedValue tag in classElem.TaggedValues)
            {
                String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name.ToLower());
                if (relevantAnnotationsNoValue.Contains(normalizedAnnotation))
                {
                    output.OutputText(depth, " //@" + normalizedAnnotation);
                }
                else if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                {
                    output.OutputText(depth, " //@" + normalizedAnnotation + " " + tag.Value);
                }
            }

            output.OutputTextLine();
        }


        private static char[] invalidTypenameChars = new char[] { ' ', '-', '&', '(', ')' };

        /**  Normalizes a user-defined UML classifier (class / package) name into a legal IDL class/module name
         * 
         */
        public static String IDL_NormalizeUserDefinedClassifierName(String classifierName)
        {
            for (int index = 0; index < invalidTypenameChars.GetLength(0); ++index) {
                classifierName = classifierName.Replace(invalidTypenameChars[index], '_');
            }

            return classifierName;
        }

        private static readonly string[] longlongTypes  = new string[] { "long long", "int64", "int64_t" };
        private static readonly string[] ulonglongTypes = new string[] { "unsigned long long", "uint64", "uint64_t" };
        private static readonly string[] longTypes      = new string[] { "long", "int", "int32", "int32_t", "integer", };
        private static readonly string[] ulongTypes     = new string[] { "unsigned long", "unsigned int", "ulong", "uint", "uint32", "uint32_t" };
        private static readonly string[] shortTypes     = new string[] { "short", "int16", "int16_t" };
        private static readonly string[] ushortTypes    = new string[] { "unsigned short", "ushort", "uint16", "uint16_t" };
        private static readonly string[] octetTypes     = new string[] { "octet", "byte", "int8", "int8_t", "uint8", "uint8_t" };
        private static readonly string[] floatTypes     = new string[] { "float", "float32", "number" };
        private static readonly string[] doubleTypes    = new string[] { "double", "float64" };

        private static readonly string[][] primtiveTypeVariations = {
            longlongTypes, ulonglongTypes, longTypes, ulongTypes, shortTypes, ushortTypes, octetTypes, floatTypes, doubleTypes };

        private static readonly Regex MultipleSpaces = new Regex(@" {2,}", RegexOptions.Compiled);

        /** Normalizes a type name converting it into a legal IDL4  type.
         *  
         * This function handles common variations of primitive type names. For anything non-primitive
         * it just calls IDL_NormalizeUserDefinedClassifierName
         */
        private static String IDL_NormalizeMemberTypeName(String typeName)
        {
            String normalizedType = MultipleSpaces.Replace(typeName, " ");
            for (int typeFamily = 0; typeFamily < primtiveTypeVariations.GetLength(0); ++typeFamily)
            {
                if (primtiveTypeVariations[typeFamily].Contains(normalizedType))
                {
                    return primtiveTypeVariations[typeFamily][0];
                }
            }

            return IDL_NormalizeUserDefinedClassifierName(normalizedType); 
        }


        private static readonly string[] keyAnnotation = new string[] { "Key", "key" };
        private static readonly string[] mustUnderstandAnnotation = new string[] { "must_understand" };

        private static readonly string[] idAnnotation = new string[] { "ID", "id" };
        private static readonly string[] autoidAnnotation = new string[] { "autoid" };
        private static readonly string[] optionalAnnotation = new string[] { "Optional", "optional" };
        private static readonly string[] valueAnnotation = new string[] { "value" };

        private static readonly string[] extensibilityAnnotation = new string[] { "Extensibility", "extensibility" };
        private static readonly string[] finalAnnotation = new string[] { "final" };
        private static readonly string[] mutableAnnotation = new string[] { "mutable" };

        private static readonly string[] defaultAnnotation = new string[] { "default" };
        private static readonly string[] rangeAnnotation = new string[] { "range" };
        private static readonly string[] minAnnotation = new string[] { "min" };
        private static readonly string[] maxAnnotation = new string[] { "max" };
        private static readonly string[] unitAnnotation = new string[] { "unit" };

        private static readonly string[] bitBoundAnnotation = new string[] { "bit_bound" };
        private static readonly string[] externalAnnotation = new string[] { "external" };
        private static readonly string[] nestedAnnotation = new string[] { "nested" };

        private static readonly string[] verbatimAnnotation = new string[] { "verbatim" };

        private static readonly string[] serviceAnnotation = new string[] { "service" };
        private static readonly string[] onewayAnnotation = new string[] { "oneway" };
        private static readonly string[] amiAnnotation = new string[]   { "ami" };



        private static readonly string[][] builtinAnnotationVariations = {
            keyAnnotation, mustUnderstandAnnotation,
            idAnnotation, autoidAnnotation, optionalAnnotation, valueAnnotation,
            extensibilityAnnotation, finalAnnotation, mutableAnnotation,
            defaultAnnotation, rangeAnnotation, minAnnotation, maxAnnotation, unitAnnotation,
            bitBoundAnnotation, externalAnnotation, nestedAnnotation,
            verbatimAnnotation,
            serviceAnnotation, onewayAnnotation, amiAnnotation
        };

        /** Normalizes an annotation type name converting it into a legal IDL4 / Connext DDS annotation.
         *  
         * This function handles common variations of capitalization for the builtin annotations. For anything 
         * non-built-in it just leaves it unchanged
         */
        private static String IDL_NormalizeAnnotationName(String annotationName)
        {
            String annotationNameLower = annotationName.ToLower();
            for (int annotationType = 0; annotationType < builtinAnnotationVariations.GetLength(0); ++annotationType)
            {
                if ( builtinAnnotationVariations[annotationType].Contains(annotationNameLower) )
                {
                    return builtinAnnotationVariations[annotationType][0];
                }
            }

            return annotationName;
        }

        /**
         * Determines whether this is a model element relevant to Connext DDS and we need to 
         * generate code associated with the model element.
         */
        private static bool IsRelevantClass(Element e)
        {
            return (e.Type == "Class") &&
                ((e.Attributes.Count > 0) || (e.Connectors.Count > 0));
        }

    }
}
